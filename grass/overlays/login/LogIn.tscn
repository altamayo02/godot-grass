[gd_scene load_steps=18 format=2]

[ext_resource path="res://assets/fonts/Dongle/Dongle-48.tres" type="DynamicFont" id=1]
[ext_resource path="res://assets/fonts/Dongle/Dongle-32.tres" type="DynamicFont" id=2]
[ext_resource path="res://overlays/login/ProfileCarousel.gd" type="Script" id=4]
[ext_resource path="res://overlays/login/LogIn.gd" type="Script" id=5]
[ext_resource path="res://assets/garty3.png" type="Texture" id=6]
[ext_resource path="res://assets/login_FILL0_wght400_GRAD0_opsz24.png" type="Texture" id=7]

[sub_resource type="VisualShaderNodeInput" id=6]
input_name = "texture"

[sub_resource type="VisualShaderNodeTexture" id=7]
source = 5

[sub_resource type="VisualShaderNodeExpression" id=8]
size = Vector2( 554, 440.28 )
expression = "vec4 rgbaBg = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0);
vec3 rgbBg = vec3(rgbaBg[0], rgbaBg[1], rgbaBg[2]);
vec3 hclBg = RGBtoHCL(rgbBg);

vec3 hclFg = RGBtoHCL(color0);

// Hue and Chroma from bottom layer
// Luma from top layer
vec3 hcl1 = vec3(hclBg[0], hclBg[1], hclFg[2]);

color1 = HCLtoRGB(hcl1);"

[sub_resource type="VisualShaderNodeGlobalExpression" id=10]
size = Vector2( 758.43, 1780.47 )
expression = "// Lots of thanks to Ian
// https://www.chilliant.com/rgb2hsv.html

const float HCLgamma = 40.0;
const float HCLy0 = 100.0;
const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
const float PI = 3.1415926536;

vec3 RGBtoHCL(vec3 RGB) {
    vec3 HCL;
    float H = 0.0;
    float U = min(RGB.r, min(RGB.g, RGB.b));
    float V = max(RGB.r, max(RGB.g, RGB.b));
    float Q = HCLgamma / HCLy0;
    HCL.y = V - U;
    if (HCL.y != 0.0) {
      H = atan(RGB.g - RGB.b, RGB.r - RGB.g) / PI;
      Q *= U / V;
    }
    Q = exp(Q);
    HCL.x = fract(H / 2.0 - min(fract(H), fract(-H)) / 6.0);
    HCL.y *= Q;
    HCL.z = mix(-U, V, Q) / (HCLmaxL * 2.0);
    return HCL;
}

vec3 HCLtoRGB(vec3 HCL)
  {
    vec3 RGB = vec3(0.0, 0.0, 0.0);
    if (HCL.z != 0.0)
    {
      float H = HCL.x;
      float C = HCL.y;
      float L = HCL.z * HCLmaxL;
      float Q = exp((1.0 - C / (2.0 * L)) * (HCLgamma / HCLy0));
      float U = (2.0 * L - C) / (2.0 * Q - 1.0);
      float V = C / Q;
      float A = (H + min(fract(2.0 * H) / 4.0, fract(-2.0 * H) / 8.0)) * PI * 2.0;
      float T;
      H *= 6.0;
      if (H <= 0.999)
      {
        T = tan(A);
        RGB.r = 1.0;
        RGB.g = T / (1.0 + T);
      }
      else if (H <= 1.001)
      {
        RGB.r = 1.0;
        RGB.g = 1.0;
      }
      else if (H <= 2.0)
      {
        T = tan(A);
        RGB.r = (1.0 + T) / T;
        RGB.g = 1.0;
      }
      else if (H <= 3.0)
      {
        T = tan(A);
        RGB.g = 1.0;
        RGB.b = 1.0 + T;
      }
      else if (H <= 3.999)
      {
        T = tan(A);
        RGB.g = 1.0 / (1.0 + T);
        RGB.b = 1.0;
      }
      else if (H <= 4.001)
      {
        RGB.g = 0.0;
        RGB.b = 1.0;
      }
      else if (H <= 5.0)
      {
        T = tan(A);
        RGB.r = -1.0 / T;
        RGB.b = 1.0;
      }
      else
      {
        T = tan(A);
        RGB.r = 1.0;
        RGB.b = -T;
      }
      RGB = RGB * V + U;
    }
    return RGB;
  }"

[sub_resource type="VisualShader" id=9]
code = "shader_type canvas_item;


// GlobalExpression:0
	// Lots of thanks to Ian
	// https://www.chilliant.com/rgb2hsv.html
	
	const float HCLgamma = 40.0;
	const float HCLy0 = 100.0;
	const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
	const float PI = 3.1415926536;
	
	vec3 RGBtoHCL(vec3 RGB) {
	    vec3 HCL;
	    float H = 0.0;
	    float U = min(RGB.r, min(RGB.g, RGB.b));
	    float V = max(RGB.r, max(RGB.g, RGB.b));
	    float Q = HCLgamma / HCLy0;
	    HCL.y = V - U;
	    if (HCL.y != 0.0) {
	      H = atan(RGB.g - RGB.b, RGB.r - RGB.g) / PI;
	      Q *= U / V;
	    }
	    Q = exp(Q);
	    HCL.x = fract(H / 2.0 - min(fract(H), fract(-H)) / 6.0);
	    HCL.y *= Q;
	    HCL.z = mix(-U, V, Q) / (HCLmaxL * 2.0);
	    return HCL;
	}
	
	vec3 HCLtoRGB(vec3 HCL)
	  {
	    vec3 RGB = vec3(0.0, 0.0, 0.0);
	    if (HCL.z != 0.0)
	    {
	      float H = HCL.x;
	      float C = HCL.y;
	      float L = HCL.z * HCLmaxL;
	      float Q = exp((1.0 - C / (2.0 * L)) * (HCLgamma / HCLy0));
	      float U = (2.0 * L - C) / (2.0 * Q - 1.0);
	      float V = C / Q;
	      float A = (H + min(fract(2.0 * H) / 4.0, fract(-2.0 * H) / 8.0)) * PI * 2.0;
	      float T;
	      H *= 6.0;
	      if (H <= 0.999)
	      {
	        T = tan(A);
	        RGB.r = 1.0;
	        RGB.g = T / (1.0 + T);
	      }
	      else if (H <= 1.001)
	      {
	        RGB.r = 1.0;
	        RGB.g = 1.0;
	      }
	      else if (H <= 2.0)
	      {
	        T = tan(A);
	        RGB.r = (1.0 + T) / T;
	        RGB.g = 1.0;
	      }
	      else if (H <= 3.0)
	      {
	        T = tan(A);
	        RGB.g = 1.0;
	        RGB.b = 1.0 + T;
	      }
	      else if (H <= 3.999)
	      {
	        T = tan(A);
	        RGB.g = 1.0 / (1.0 + T);
	        RGB.b = 1.0;
	      }
	      else if (H <= 4.001)
	      {
	        RGB.g = 0.0;
	        RGB.b = 1.0;
	      }
	      else if (H <= 5.0)
	      {
	        T = tan(A);
	        RGB.r = -1.0 / T;
	        RGB.b = 1.0;
	      }
	      else
	      {
	        T = tan(A);
	        RGB.r = 1.0;
	        RGB.b = -T;
	      }
	      RGB = RGB * V + U;
	    }
	    return RGB;
	  }

void vertex() {
// Output:0

}

void fragment() {
// Input:6

// Texture:7
	vec3 n_out7p0;
	float n_out7p1;
	{
		vec4 TEXTURE_tex_read = texture(TEXTURE, UV.xy);
		n_out7p0 = TEXTURE_tex_read.rgb;
		n_out7p1 = TEXTURE_tex_read.a;
	}

// Expression:8
	vec3 n_out8p0;
	n_out8p0 = vec3(0.0, 0.0, 0.0);
	{
		vec4 rgbaBg = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0);
		vec3 rgbBg = vec3(rgbaBg[0], rgbaBg[1], rgbaBg[2]);
		vec3 hclBg = RGBtoHCL(rgbBg);
		
		vec3 hclFg = RGBtoHCL(n_out7p0);
		
		// Hue and Chroma from bottom layer
		// Luma from top layer
		vec3 hcl1 = vec3(hclBg[0], hclBg[1], hclFg[2]);
		
		n_out8p0 = HCLtoRGB(hcl1);
	}

// Output:0
	COLOR.rgb = n_out8p0;
	COLOR.a = n_out7p1;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -531.356, -326.257 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 660, 420 )
nodes/fragment/6/node = SubResource( 6 )
nodes/fragment/6/position = Vector2( -360, 480 )
nodes/fragment/7/node = SubResource( 7 )
nodes/fragment/7/position = Vector2( -180, 420 )
nodes/fragment/8/node = SubResource( 8 )
nodes/fragment/8/position = Vector2( 60, -20 )
nodes/fragment/8/size = Vector2( 554, 440.28 )
nodes/fragment/8/input_ports = "0,1,color0;"
nodes/fragment/8/output_ports = "0,1,color1;"
nodes/fragment/8/expression = "vec4 rgbaBg = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0);
vec3 rgbBg = vec3(rgbaBg[0], rgbaBg[1], rgbaBg[2]);
vec3 hclBg = RGBtoHCL(rgbBg);

vec3 hclFg = RGBtoHCL(color0);

// Hue and Chroma from bottom layer
// Luma from top layer
vec3 hcl1 = vec3(hclBg[0], hclBg[1], hclFg[2]);

color1 = HCLtoRGB(hcl1);"
nodes/fragment/9/node = SubResource( 10 )
nodes/fragment/9/position = Vector2( 920, -500 )
nodes/fragment/9/size = Vector2( 758.43, 1780.47 )
nodes/fragment/9/input_ports = ""
nodes/fragment/9/output_ports = ""
nodes/fragment/9/expression = "// Lots of thanks to Ian
// https://www.chilliant.com/rgb2hsv.html

const float HCLgamma = 40.0;
const float HCLy0 = 100.0;
const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
const float PI = 3.1415926536;

vec3 RGBtoHCL(vec3 RGB) {
    vec3 HCL;
    float H = 0.0;
    float U = min(RGB.r, min(RGB.g, RGB.b));
    float V = max(RGB.r, max(RGB.g, RGB.b));
    float Q = HCLgamma / HCLy0;
    HCL.y = V - U;
    if (HCL.y != 0.0) {
      H = atan(RGB.g - RGB.b, RGB.r - RGB.g) / PI;
      Q *= U / V;
    }
    Q = exp(Q);
    HCL.x = fract(H / 2.0 - min(fract(H), fract(-H)) / 6.0);
    HCL.y *= Q;
    HCL.z = mix(-U, V, Q) / (HCLmaxL * 2.0);
    return HCL;
}

vec3 HCLtoRGB(vec3 HCL)
  {
    vec3 RGB = vec3(0.0, 0.0, 0.0);
    if (HCL.z != 0.0)
    {
      float H = HCL.x;
      float C = HCL.y;
      float L = HCL.z * HCLmaxL;
      float Q = exp((1.0 - C / (2.0 * L)) * (HCLgamma / HCLy0));
      float U = (2.0 * L - C) / (2.0 * Q - 1.0);
      float V = C / Q;
      float A = (H + min(fract(2.0 * H) / 4.0, fract(-2.0 * H) / 8.0)) * PI * 2.0;
      float T;
      H *= 6.0;
      if (H <= 0.999)
      {
        T = tan(A);
        RGB.r = 1.0;
        RGB.g = T / (1.0 + T);
      }
      else if (H <= 1.001)
      {
        RGB.r = 1.0;
        RGB.g = 1.0;
      }
      else if (H <= 2.0)
      {
        T = tan(A);
        RGB.r = (1.0 + T) / T;
        RGB.g = 1.0;
      }
      else if (H <= 3.0)
      {
        T = tan(A);
        RGB.g = 1.0;
        RGB.b = 1.0 + T;
      }
      else if (H <= 3.999)
      {
        T = tan(A);
        RGB.g = 1.0 / (1.0 + T);
        RGB.b = 1.0;
      }
      else if (H <= 4.001)
      {
        RGB.g = 0.0;
        RGB.b = 1.0;
      }
      else if (H <= 5.0)
      {
        T = tan(A);
        RGB.r = -1.0 / T;
        RGB.b = 1.0;
      }
      else
      {
        T = tan(A);
        RGB.r = 1.0;
        RGB.b = -T;
      }
      RGB = RGB * V + U;
    }
    return RGB;
  }"
nodes/fragment/connections = PoolIntArray( 7, 1, 0, 1, 6, 0, 7, 2, 8, 0, 0, 0, 7, 0, 8, 0 )

[sub_resource type="ShaderMaterial" id=5]
shader = SubResource( 9 )

[sub_resource type="StyleBoxFlat" id=14]
bg_color = Color( 0.380392, 0.576471, 0.388235, 1 )
draw_center = false
border_width_left = 5
border_width_top = 5
border_width_right = 5
border_width_bottom = 5
border_color = Color( 0.380392, 0.576471, 0.388235, 1 )
corner_radius_top_left = 15
corner_radius_top_right = 15
corner_radius_bottom_right = 15
corner_radius_bottom_left = 15

[sub_resource type="CanvasItemMaterial" id=12]

[sub_resource type="StyleBoxFlat" id=13]
bg_color = Color( 0.486275, 0.384314, 0.113725, 1 )
border_width_left = 10
border_width_top = 5
border_width_right = 5
border_width_bottom = 10
border_color = Color( 0.611765, 0.517647, 0.235294, 1 )
corner_radius_top_left = 75
corner_radius_top_right = 75
corner_radius_bottom_right = 75
corner_radius_bottom_left = 75
corner_detail = 16

[sub_resource type="StyleBoxFlat" id=16]
bg_color = Color( 0.611765, 0.517647, 0.235294, 1 )
border_width_left = 5
border_width_top = 5
border_width_right = 5
border_width_bottom = 5
border_color = Color( 0.486275, 0.384314, 0.113725, 1 )
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[sub_resource type="StyleBoxFlat" id=15]
bg_color = Color( 0.768627, 0.843137, 0.803922, 1 )
border_width_left = 5
border_width_top = 5
border_width_right = 5
border_width_bottom = 5
border_color = Color( 0.486275, 0.384314, 0.113725, 1 )
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

[node name="LogIn" type="Control"]
anchor_right = 1.0
anchor_bottom = 1.0
script = ExtResource( 5 )
__meta__ = {
"_edit_use_anchors_": true
}

[node name="Background" type="Control" parent="."]
anchor_right = 1.0
anchor_bottom = 1.0
rect_pivot_offset = Vector2( 800, 450 )
__meta__ = {
"_edit_use_anchors_": true
}

[node name="BackgroundColor" type="ColorRect" parent="Background"]
anchor_right = 1.0
anchor_bottom = 1.0
color = Color( 0.0745098, 0.14902, 0.109804, 1 )
__meta__ = {
"_edit_use_anchors_": true
}

[node name="TextureRect" type="TextureRect" parent="Background"]
material = SubResource( 5 )
anchor_left = 0.0292969
anchor_top = 0.25
anchor_right = 0.322266
anchor_bottom = 0.75
margin_left = -1.87504
margin_right = -20.6256
rect_pivot_offset = Vector2( 225, 225 )
texture = ExtResource( 6 )
expand = true
stretch_mode = 5
__meta__ = {
"_edit_use_anchors_": true
}

[node name="ProfileCarousel" type="Container" parent="."]
anchor_left = 0.5
anchor_right = 0.5
anchor_bottom = 1.0
mouse_filter = 1
script = ExtResource( 4 )

[node name="Selected" type="Panel" parent="ProfileCarousel"]
visible = false
margin_right = 400.0
margin_bottom = 900.0
mouse_filter = 1
custom_styles/panel = SubResource( 14 )

[node name="AspectRatioContainer" type="AspectRatioContainer" parent="."]
anchor_left = 0.875
anchor_top = 0.416667
anchor_right = 0.96875
anchor_bottom = 0.583333
__meta__ = {
"_edit_use_anchors_": true
}

[node name="Panel" type="Panel" parent="AspectRatioContainer"]
material = SubResource( 12 )
margin_right = 150.0
margin_bottom = 150.0
custom_styles/panel = SubResource( 13 )

[node name="TextureRect" type="TextureRect" parent="AspectRatioContainer/Panel"]
anchor_left = 0.166667
anchor_top = 0.166667
anchor_right = 0.833334
anchor_bottom = 0.833334
margin_right = 900.0
margin_bottom = 900.0
rect_scale = Vector2( 0.1, 0.1 )
texture = ExtResource( 7 )
__meta__ = {
"_edit_use_anchors_": true
}

[node name="Contraseña" type="VBoxContainer" parent="."]
anchor_left = 0.65625
anchor_top = 0.4
anchor_right = 0.828125
anchor_bottom = 0.546667
alignment = 1
__meta__ = {
"_edit_use_anchors_": true
}

[node name="Label" type="Label" parent="Contraseña"]
margin_right = 275.0
margin_bottom = 70.0
custom_colors/font_color = Color( 0.611765, 0.517647, 0.235294, 1 )
custom_fonts/font = ExtResource( 1 )
text = "Contraseña"
__meta__ = {
"_edit_use_anchors_": true
}

[node name="LineEdit" type="LineEdit" parent="Contraseña"]
margin_top = 74.0
margin_right = 275.0
margin_bottom = 132.0
custom_colors/cursor_color = Color( 0.486275, 0.384314, 0.113725, 1 )
custom_colors/font_color = Color( 0.486275, 0.384314, 0.113725, 1 )
custom_fonts/font = ExtResource( 2 )
custom_styles/read_only = SubResource( 16 )
custom_styles/normal = SubResource( 15 )
editable = false
secret = true
clear_button_enabled = true
caret_blink = true
__meta__ = {
"_edit_use_anchors_": true
}

[connection signal="mouse_entered" from="ProfileCarousel" to="ProfileCarousel" method="_on_ProfileRoulette_mouse_entered"]
[connection signal="mouse_exited" from="ProfileCarousel" to="ProfileCarousel" method="_on_ProfileRoulette_mouse_exited"]
[connection signal="scrolling" from="ProfileCarousel" to="ProfileCarousel" method="_on_ProfileCarousel_scrolling"]
[connection signal="gui_input" from="AspectRatioContainer/Panel" to="." method="_on_Panel_gui_input"]
