[gd_scene load_steps=10 format=2]

[ext_resource path="res://gui/screens/login/LogIn.gd" type="Script" id=1]
[ext_resource path="res://gui/assets/garty3.png" type="Texture" id=2]
[ext_resource path="res://gui/screens/login/Profile.tscn" type="PackedScene" id=3]

[sub_resource type="VisualShaderNodeInput" id=6]
input_name = "texture"

[sub_resource type="VisualShaderNodeTexture" id=7]
source = 5

[sub_resource type="VisualShaderNodeExpression" id=8]
size = Vector2( 554, 440.28 )
expression = "vec4 rgbaBg = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0);
vec3 rgbBg = vec3(rgbaBg[0], rgbaBg[1], rgbaBg[2]);
vec3 hclBg = RGBtoHCL(rgbBg);

vec3 hclFg = RGBtoHCL(color0);

// Hue and Chroma from bottom layer
// Luma from top layer
vec3 hcl1 = vec3(hclBg[0], hclBg[1], hclFg[2]);

color1 = HCLtoRGB(hcl1);"

[sub_resource type="VisualShaderNodeGlobalExpression" id=10]
size = Vector2( 758.43, 1780.47 )
expression = "// Lots of thanks to Ian
// https://www.chilliant.com/rgb2hsv.html

const float HCLgamma = 40.0;
const float HCLy0 = 100.0;
const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
const float PI = 3.1415926536;

vec3 RGBtoHCL(vec3 RGB) {
    vec3 HCL;
    float H = 0.0;
    float U = min(RGB.r, min(RGB.g, RGB.b));
    float V = max(RGB.r, max(RGB.g, RGB.b));
    float Q = HCLgamma / HCLy0;
    HCL.y = V - U;
    if (HCL.y != 0.0) {
      H = atan(RGB.g - RGB.b, RGB.r - RGB.g) / PI;
      Q *= U / V;
    }
    Q = exp(Q);
    HCL.x = fract(H / 2.0 - min(fract(H), fract(-H)) / 6.0);
    HCL.y *= Q;
    HCL.z = mix(-U, V, Q) / (HCLmaxL * 2.0);
    return HCL;
}

vec3 HCLtoRGB(vec3 HCL)
  {
    vec3 RGB = vec3(0.0, 0.0, 0.0);
    if (HCL.z != 0.0)
    {
      float H = HCL.x;
      float C = HCL.y;
      float L = HCL.z * HCLmaxL;
      float Q = exp((1.0 - C / (2.0 * L)) * (HCLgamma / HCLy0));
      float U = (2.0 * L - C) / (2.0 * Q - 1.0);
      float V = C / Q;
      float A = (H + min(fract(2.0 * H) / 4.0, fract(-2.0 * H) / 8.0)) * PI * 2.0;
      float T;
      H *= 6.0;
      if (H <= 0.999)
      {
        T = tan(A);
        RGB.r = 1.0;
        RGB.g = T / (1.0 + T);
      }
      else if (H <= 1.001)
      {
        RGB.r = 1.0;
        RGB.g = 1.0;
      }
      else if (H <= 2.0)
      {
        T = tan(A);
        RGB.r = (1.0 + T) / T;
        RGB.g = 1.0;
      }
      else if (H <= 3.0)
      {
        T = tan(A);
        RGB.g = 1.0;
        RGB.b = 1.0 + T;
      }
      else if (H <= 3.999)
      {
        T = tan(A);
        RGB.g = 1.0 / (1.0 + T);
        RGB.b = 1.0;
      }
      else if (H <= 4.001)
      {
        RGB.g = 0.0;
        RGB.b = 1.0;
      }
      else if (H <= 5.0)
      {
        T = tan(A);
        RGB.r = -1.0 / T;
        RGB.b = 1.0;
      }
      else
      {
        T = tan(A);
        RGB.r = 1.0;
        RGB.b = -T;
      }
      RGB = RGB * V + U;
    }
    return RGB;
  }"

[sub_resource type="VisualShader" id=9]
code = "shader_type canvas_item;


// GlobalExpression:0
	// Lots of thanks to Ian
	// https://www.chilliant.com/rgb2hsv.html
	
	const float HCLgamma = 40.0;
	const float HCLy0 = 100.0;
	const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
	const float PI = 3.1415926536;
	
	vec3 RGBtoHCL(vec3 RGB) {
	    vec3 HCL;
	    float H = 0.0;
	    float U = min(RGB.r, min(RGB.g, RGB.b));
	    float V = max(RGB.r, max(RGB.g, RGB.b));
	    float Q = HCLgamma / HCLy0;
	    HCL.y = V - U;
	    if (HCL.y != 0.0) {
	      H = atan(RGB.g - RGB.b, RGB.r - RGB.g) / PI;
	      Q *= U / V;
	    }
	    Q = exp(Q);
	    HCL.x = fract(H / 2.0 - min(fract(H), fract(-H)) / 6.0);
	    HCL.y *= Q;
	    HCL.z = mix(-U, V, Q) / (HCLmaxL * 2.0);
	    return HCL;
	}
	
	vec3 HCLtoRGB(vec3 HCL)
	  {
	    vec3 RGB = vec3(0.0, 0.0, 0.0);
	    if (HCL.z != 0.0)
	    {
	      float H = HCL.x;
	      float C = HCL.y;
	      float L = HCL.z * HCLmaxL;
	      float Q = exp((1.0 - C / (2.0 * L)) * (HCLgamma / HCLy0));
	      float U = (2.0 * L - C) / (2.0 * Q - 1.0);
	      float V = C / Q;
	      float A = (H + min(fract(2.0 * H) / 4.0, fract(-2.0 * H) / 8.0)) * PI * 2.0;
	      float T;
	      H *= 6.0;
	      if (H <= 0.999)
	      {
	        T = tan(A);
	        RGB.r = 1.0;
	        RGB.g = T / (1.0 + T);
	      }
	      else if (H <= 1.001)
	      {
	        RGB.r = 1.0;
	        RGB.g = 1.0;
	      }
	      else if (H <= 2.0)
	      {
	        T = tan(A);
	        RGB.r = (1.0 + T) / T;
	        RGB.g = 1.0;
	      }
	      else if (H <= 3.0)
	      {
	        T = tan(A);
	        RGB.g = 1.0;
	        RGB.b = 1.0 + T;
	      }
	      else if (H <= 3.999)
	      {
	        T = tan(A);
	        RGB.g = 1.0 / (1.0 + T);
	        RGB.b = 1.0;
	      }
	      else if (H <= 4.001)
	      {
	        RGB.g = 0.0;
	        RGB.b = 1.0;
	      }
	      else if (H <= 5.0)
	      {
	        T = tan(A);
	        RGB.r = -1.0 / T;
	        RGB.b = 1.0;
	      }
	      else
	      {
	        T = tan(A);
	        RGB.r = 1.0;
	        RGB.b = -T;
	      }
	      RGB = RGB * V + U;
	    }
	    return RGB;
	  }

void vertex() {
// Output:0

}

void fragment() {
// Input:6

// Texture:7
	vec3 n_out7p0;
	float n_out7p1;
	{
		vec4 TEXTURE_tex_read = texture(TEXTURE, UV.xy);
		n_out7p0 = TEXTURE_tex_read.rgb;
		n_out7p1 = TEXTURE_tex_read.a;
	}

// Expression:8
	vec3 n_out8p0;
	n_out8p0 = vec3(0.0, 0.0, 0.0);
	{
		vec4 rgbaBg = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0);
		vec3 rgbBg = vec3(rgbaBg[0], rgbaBg[1], rgbaBg[2]);
		vec3 hclBg = RGBtoHCL(rgbBg);
		
		vec3 hclFg = RGBtoHCL(n_out7p0);
		
		// Hue and Chroma from bottom layer
		// Luma from top layer
		vec3 hcl1 = vec3(hclBg[0], hclBg[1], hclFg[2]);
		
		n_out8p0 = HCLtoRGB(hcl1);
	}

// Output:0
	COLOR.rgb = n_out8p0;
	COLOR.a = n_out7p1;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -531.356, -326.257 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 660, 420 )
nodes/fragment/6/node = SubResource( 6 )
nodes/fragment/6/position = Vector2( -360, 480 )
nodes/fragment/7/node = SubResource( 7 )
nodes/fragment/7/position = Vector2( -180, 420 )
nodes/fragment/8/node = SubResource( 8 )
nodes/fragment/8/position = Vector2( 60, -20 )
nodes/fragment/8/size = Vector2( 554, 440.28 )
nodes/fragment/8/input_ports = "0,1,color0;"
nodes/fragment/8/output_ports = "0,1,color1;"
nodes/fragment/8/expression = "vec4 rgbaBg = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0);
vec3 rgbBg = vec3(rgbaBg[0], rgbaBg[1], rgbaBg[2]);
vec3 hclBg = RGBtoHCL(rgbBg);

vec3 hclFg = RGBtoHCL(color0);

// Hue and Chroma from bottom layer
// Luma from top layer
vec3 hcl1 = vec3(hclBg[0], hclBg[1], hclFg[2]);

color1 = HCLtoRGB(hcl1);"
nodes/fragment/9/node = SubResource( 10 )
nodes/fragment/9/position = Vector2( 920, -500 )
nodes/fragment/9/size = Vector2( 758.43, 1780.47 )
nodes/fragment/9/input_ports = ""
nodes/fragment/9/output_ports = ""
nodes/fragment/9/expression = "// Lots of thanks to Ian
// https://www.chilliant.com/rgb2hsv.html

const float HCLgamma = 40.0;
const float HCLy0 = 100.0;
const float HCLmaxL = 0.530454533953517; // == exp(HCLgamma / HCLy0) - 0.5
const float PI = 3.1415926536;

vec3 RGBtoHCL(vec3 RGB) {
    vec3 HCL;
    float H = 0.0;
    float U = min(RGB.r, min(RGB.g, RGB.b));
    float V = max(RGB.r, max(RGB.g, RGB.b));
    float Q = HCLgamma / HCLy0;
    HCL.y = V - U;
    if (HCL.y != 0.0) {
      H = atan(RGB.g - RGB.b, RGB.r - RGB.g) / PI;
      Q *= U / V;
    }
    Q = exp(Q);
    HCL.x = fract(H / 2.0 - min(fract(H), fract(-H)) / 6.0);
    HCL.y *= Q;
    HCL.z = mix(-U, V, Q) / (HCLmaxL * 2.0);
    return HCL;
}

vec3 HCLtoRGB(vec3 HCL)
  {
    vec3 RGB = vec3(0.0, 0.0, 0.0);
    if (HCL.z != 0.0)
    {
      float H = HCL.x;
      float C = HCL.y;
      float L = HCL.z * HCLmaxL;
      float Q = exp((1.0 - C / (2.0 * L)) * (HCLgamma / HCLy0));
      float U = (2.0 * L - C) / (2.0 * Q - 1.0);
      float V = C / Q;
      float A = (H + min(fract(2.0 * H) / 4.0, fract(-2.0 * H) / 8.0)) * PI * 2.0;
      float T;
      H *= 6.0;
      if (H <= 0.999)
      {
        T = tan(A);
        RGB.r = 1.0;
        RGB.g = T / (1.0 + T);
      }
      else if (H <= 1.001)
      {
        RGB.r = 1.0;
        RGB.g = 1.0;
      }
      else if (H <= 2.0)
      {
        T = tan(A);
        RGB.r = (1.0 + T) / T;
        RGB.g = 1.0;
      }
      else if (H <= 3.0)
      {
        T = tan(A);
        RGB.g = 1.0;
        RGB.b = 1.0 + T;
      }
      else if (H <= 3.999)
      {
        T = tan(A);
        RGB.g = 1.0 / (1.0 + T);
        RGB.b = 1.0;
      }
      else if (H <= 4.001)
      {
        RGB.g = 0.0;
        RGB.b = 1.0;
      }
      else if (H <= 5.0)
      {
        T = tan(A);
        RGB.r = -1.0 / T;
        RGB.b = 1.0;
      }
      else
      {
        T = tan(A);
        RGB.r = 1.0;
        RGB.b = -T;
      }
      RGB = RGB * V + U;
    }
    return RGB;
  }"
nodes/fragment/connections = PoolIntArray( 7, 1, 0, 1, 6, 0, 7, 2, 8, 0, 0, 0, 7, 0, 8, 0 )

[sub_resource type="ShaderMaterial" id=5]
shader = SubResource( 9 )

[node name="LogIn" type="Control"]
anchor_right = 1.0
anchor_bottom = 1.0
script = ExtResource( 1 )
__meta__ = {
"_edit_use_anchors_": true
}

[node name="Background" type="Control" parent="."]
anchor_right = 1.0
anchor_bottom = 1.0
__meta__ = {
"_edit_use_anchors_": true
}

[node name="BackgroundColor" type="ColorRect" parent="Background"]
anchor_right = 1.0
anchor_bottom = 1.0
color = Color( 0.0745098, 0.14902, 0.109804, 1 )
__meta__ = {
"_edit_use_anchors_": true
}

[node name="TextureRect" type="TextureRect" parent="Background"]
material = SubResource( 5 )
anchor_left = 0.0292969
anchor_top = 0.25
anchor_right = 0.322266
anchor_bottom = 0.75
texture = ExtResource( 2 )
expand = true
stretch_mode = 5
__meta__ = {
"_edit_use_anchors_": true
}

[node name="Profiles" type="AspectRatioContainer" parent="."]
anchor_left = 0.375
anchor_right = 0.625
anchor_bottom = 1.0
__meta__ = {
"_edit_use_anchors_": true
}

[node name="Frame" parent="Profiles" instance=ExtResource( 3 )]
margin_top = 250.0
margin_right = 400.0
margin_bottom = 650.0
